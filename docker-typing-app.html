<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docker学習タイピングアプリ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #D8E8F2 0%, #ffffff 100%);
            min-height: 100vh;
            color: #333333;
            overflow-x: hidden;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 25px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            animation: fadeInDown 1s ease-out;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #55BF24, #A8D977);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 600;
        }

        .header p {
            color: #666666;
            font-size: 1.1rem;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            background: white;
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            animation: slideInUp 1s ease-out;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            border: 1px solid rgba(216,232,242,0.5);
        }

        .stat-item {
            text-align: center;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #666666;
            font-weight: 500;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #55BF24;
            margin-top: 4px;
        }

        .level-info {
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            animation: fadeIn 1s ease-out;
            position: relative;
        }

        .speech-controls {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(216,232,242,0.6);
        }

        .speech-btn {
            padding: 10px 18px;
            background: linear-gradient(135deg, #A8D977, #DCF2BB);
            border: none;
            border-radius: 20px;
            color: #333333;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            box-shadow: 0 2px 10px rgba(168,217,119,0.3);
        }

        .speech-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(168,217,119,0.4);
        }

        .speech-btn:disabled {
            background: #f0f0f0;
            color: #cccccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .speech-settings {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-left: auto;
        }

        .speech-speed {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
            color: #666666;
        }

        .speed-slider {
            width: 70px;
            height: 6px;
            background: #D8E8F2;
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        .speed-slider::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            background: #55BF24;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(85,191,36,0.3);
        }

        .auto-speech-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
            color: #666666;
        }

        .toggle-switch {
            position: relative;
            width: 44px;
            height: 24px;
            background: #D8E8F2;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .toggle-switch.active {
            background: #55BF24;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        .toggle-switch.active::after {
            left: 22px;
        }

        .speaking-indicator {
            position: absolute;
            top: 25px;
            right: 25px;
            background: #55BF24;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.85rem;
            opacity: 0;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 15px rgba(85,191,36,0.3);
        }

        .speaking-indicator.show {
            opacity: 1;
        }

        .wave-animation {
            width: 16px;
            height: 16px;
            background: repeating-linear-gradient(
                90deg,
                transparent,
                transparent 2px,
                white 2px,
                white 4px
            );
            border-radius: 2px;
            animation: waveMove 1s infinite linear;
        }

        @keyframes waveMove {
            0% { transform: translateX(0); }
            100% { transform: translateX(4px); }
        }

        .level-title {
            font-size: 1.3rem;
            color: #00d4ff;
            margin-bottom: 10px;
        }

        .level-description {
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .command-explanation {
            background: #DCF2BB;
            border-left: 4px solid #55BF24;
            padding: 20px;
            border-radius: 0 15px 15px 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
        }

        .explanation-section {
            margin-bottom: 15px;
            line-height: 1.6;
            color: #333333;
        }

        .explanation-section:last-child {
            margin-bottom: 0;
        }

        .practical-use {
            background: rgba(85,191,36,0.1);
            border-left: 3px solid #55BF24;
            padding: 12px 16px;
            border-radius: 0 10px 10px 0;
            margin: 12px 0;
            font-size: 0.95rem;
            color: #2d4a1a;
        }

        .analogy-section {
            background: rgba(168,217,119,0.2);
            border-left: 3px solid #A8D977;
            padding: 12px 16px;
            border-radius: 0 10px 10px 0;
            margin: 12px 0;
            font-size: 0.95rem;
            color: #2d4a1a;
        }

        .typing-area {
            background: white;
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 20px;
            animation: slideIn 1s ease-out;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            border: 1px solid rgba(216,232,242,0.5);
        }

        .target-text {
            font-size: 1.4rem;
            line-height: 1.8;
            margin-bottom: 25px;
            padding: 20px;
            background: #DCF2BB;
            border-radius: 15px;
            min-height: 80px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            color: #333333;
        }

        .target-text.active {
            border-color: #55BF24;
            box-shadow: 0 0 20px rgba(85,191,36,0.3);
        }

        .char {
            position: relative;
            transition: all 0.2s ease;
        }

        .char.correct {
            background-color: rgba(85,191,36,0.3);
            color: #55BF24;
            border-radius: 3px;
        }

        .char.incorrect {
            background-color: rgba(255,99,99,0.3);
            color: #ff4444;
            border-radius: 3px;
        }

        .char.current {
            background-color: #55BF24;
            color: white;
            border-radius: 3px;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.5; }
        }

        .input-area {
            position: relative;
        }

        #typing-input {
            width: 100%;
            padding: 18px;
            font-size: 1.2rem;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            background: #f8f9fa;
            border: 2px solid #D8E8F2;
            border-radius: 15px;
            color: #333333;
            outline: none;
            transition: all 0.3s ease;
        }

        #typing-input:focus {
            box-shadow: 0 0 20px rgba(85,191,36,0.3);
            background: white;
            border-color: #55BF24;
        }

        #typing-input::placeholder {
            color: #999999;
        }

        .progress-bar {
            background: #f0f0f0;
            border-radius: 25px;
            height: 8px;
            margin: 25px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #55BF24, #A8D977);
            border-radius: 25px;
            width: 0%;
            transition: width 0.3s ease;
        }

        .buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        .btn {
            padding: 14px 28px;
            background: linear-gradient(135deg, #55BF24, #A8D977);
            border: none;
            border-radius: 25px;
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
            box-shadow: 0 4px 15px rgba(85,191,36,0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(85,191,36,0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .results {
            background: white;
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            margin-top: 20px;
            text-align: center;
            display: none;
            animation: bounceIn 0.8s ease-out;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            border: 1px solid rgba(216,232,242,0.5);
        }

        .results.show {
            display: block;
        }

        .results h3 {
            color: #55BF24;
            margin-bottom: 15px;
        }

        .results p {
            color: #555555;
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes bounceIn {
            0% {
                opacity: 0;
                transform: scale(0.3);
            }
            50% {
                opacity: 1;
                transform: scale(1.05);
            }
            70% {
                transform: scale(0.9);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        .level-selector {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .level-btn {
            padding: 10px 18px;
            background: white;
            border: 2px solid #D8E8F2;
            border-radius: 25px;
            color: #666666;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            font-weight: 500;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .level-btn:hover {
            background: #f8f9fa;
            border-color: #A8D977;
        }

        .level-btn.active {
            border-color: #55BF24;
            background: #55BF24;
            color: white;
            box-shadow: 0 4px 15px rgba(85,191,36,0.3);
        }

        .mistake-indicator {
            position: absolute;
            top: -35px;
            left: 50%;
            transform: translateX(-50%);
            background: #ff6b6b;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 500;
            opacity: 0;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255,107,107,0.3);
        }

        .mistake-indicator.show {
            opacity: 1;
            top: -45px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .stats {
                flex-direction: column;
                gap: 15px;
            }
            
            .buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .speech-controls {
                flex-direction: column;
                gap: 15px;
                align-items: stretch;
            }
            
            .speech-settings {
                margin-left: 0;
                justify-content: space-between;
            }
            
            .level-selector {
                gap: 8px;
            }
            
            .level-btn {
                font-size: 0.8rem;
                padding: 8px 14px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Docker学習タイピング</h1>
            <p>Dockerコマンドを覚えながらタイピングスキルを向上させよう</p>
        </div>

        <div class="stats">
            <div class="stat-item">
                <div class="stat-label">WPM</div>
                <div class="stat-value" id="wpm">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">精度</div>
                <div class="stat-value" id="accuracy">100%</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">レベル</div>
                <div class="stat-value" id="current-level">1</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">進捗</div>
                <div class="stat-value" id="progress">0/10</div>
            </div>
        </div>

        <div class="level-selector">
            <div class="level-btn active" data-level="0">基本コマンド</div>
            <div class="level-btn" data-level="1">Dockerfile基礎</div>
            <div class="level-btn" data-level="2">コンテナ操作</div>
            <div class="level-btn" data-level="3">イメージ管理</div>
            <div class="level-btn" data-level="4">実践応用</div>
        </div>

        <div class="level-info">
            <div class="level-title" id="level-title">レベル1: 基本コマンド</div>
            <div class="level-description" id="level-description">
                Dockerの最も基本的なコマンドを学習します。これらのコマンドは日常的に使用する重要なものです。
            </div>
            <div class="command-explanation" id="command-explanation">
                <div class="explanation-section">docker --version: Dockerのバージョンを確認するコマンドです。インストールされているDockerの情報を表示します。</div>
                <div class="practical-use">🔧 具体的にできること：システム管理者がサーバーにDockerが正しくインストールされているか確認したり、チーム開発で全員が同じバージョンを使っているか確認できます。</div>
                <div class="analogy-section">📱 例え話：スマホの「設定」→「端末情報」でOSバージョンを確認するのと同じ。何が入っているか、どのバージョンかを知ることから全てが始まります。</div>
            </div>
            
            <div class="speech-controls">
                <button class="speech-btn" id="read-explanation-btn">
                    🔊 説明を読み上げ
                </button>
                <button class="speech-btn" id="stop-speech-btn" disabled>
                    ⏹️ 停止
                </button>
                
                <div class="speech-settings">
                    <div class="speech-speed">
                        遅く <input type="range" class="speed-slider" id="speech-speed" min="0.5" max="2" step="0.1" value="1"> 速く
                    </div>
                    <div class="auto-speech-toggle">
                        <span>自動読み上げ</span>
                        <div class="toggle-switch" id="auto-speech-toggle"></div>
                    </div>
                </div>
            </div>
            
            <div class="speaking-indicator" id="speaking-indicator">
                <div class="wave-animation"></div>
                読み上げ中...
            </div>
        </div>

        <div class="typing-area">
            <div class="target-text" id="target-text">docker --version</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div class="input-area">
                <input type="text" id="typing-input" placeholder="ここにタイピングしてください..." autocomplete="off">
                <div class="mistake-indicator" id="mistake-indicator">間違いです！</div>
            </div>
        </div>

        <div class="buttons">
            <button class="btn" id="start-btn">開始</button>
            <button class="btn" id="reset-btn">リセット</button>
            <button class="btn" id="next-btn" style="display: none;">次へ</button>
        </div>

        <div class="results" id="results">
            <h3>完了！</h3>
            <p id="final-stats"></p>
            <p id="level-complete-message"></p>
        </div>
    </div>

    <script>
        const dockerCommands = [
            {
                level: "基本コマンド",
                description: "Dockerの最も基本的なコマンドを学習します。これらのコマンドは日常的に使用する重要なものです。",
                commands: [
                    {
                        text: "docker --version",
                        explanation: "Dockerのバージョンを確認するコマンドです。インストールされているDockerの情報を表示します。",
                        practical: "🔧 具体的にできること：システム管理者がサーバーにDockerが正しくインストールされているか確認したり、チーム開発で全員が同じバージョンを使っているか確認できます。",
                        analogy: "📱 例え話：スマホの「設定」→「端末情報」でOSバージョンを確認するのと同じ。何が入っているか、どのバージョンかを知ることから全てが始まります。"
                    },
                    {
                        text: "docker images",
                        explanation: "ローカルに保存されているDockerイメージの一覧を表示します。",
                        practical: "📚 具体的にできること：どんなアプリやツールがPCに保存されているか一覧でき、不要なイメージを見つけてディスク容量を管理できます。",
                        analogy: "📖 例え話：本棚にある本の一覧を見るようなもの。どんな本（イメージ）があるか、どのくらいの厚さ（サイズ）か、いつ買った（作成日）かが分かります。"
                    },
                    {
                        text: "docker ps",
                        explanation: "現在実行中のコンテナの一覧を表示します。",
                        practical: "👀 具体的にできること：Webサーバーやデータベースなど、今動いているサービスを監視したり、パフォーマンス問題の原因を特定できます。",
                        analogy: "🏃 例え話：ジムで「今走っている人」だけを見るようなもの。どのマシンで誰が運動中かを確認できます。休憩中の人は見えません。"
                    },
                    {
                        text: "docker ps -a",
                        explanation: "停止中のコンテナも含めて、すべてのコンテナの一覧を表示します。",
                        practical: "📋 具体的にできること：過去に実行したテストや、エラーで止まったコンテナも確認でき、トラブルシューティングやクリーンアップに役立ちます。",
                        analogy: "🏃 例え話：ジムの「今日来た全員のリスト」を見るようなもの。現在運動中の人も、既に帰った人も、休憩中の人も全部表示されます。"
                    },
                    {
                        text: "docker pull ubuntu:20.04",
                        explanation: "Docker Hubから指定したイメージ（ここではUbuntu 20.04）をダウンロードします。",
                        practical: "⬇️ 具体的にできること：最新のLinux環境や、他の人が作ったアプリケーションをワンクリックでPCに取り込めます。環境構築時間を大幅短縮！",
                        analogy: "📱 例え話：アプリストアから好きなアプリをダウンロードするのと同じ。ただし、アプリではなく「完全なコンピュータ環境」をダウンロードしている感じです。"
                    },
                    {
                        text: "docker run hello-world",
                        explanation: "hello-worldイメージを使って新しいコンテナを作成・実行します。Dockerの動作確認によく使われます。",
                        practical: "✅ 具体的にできること：Dockerが正しく動作するかテストできます。新しいサーバーや開発環境でDockerセットアップ後の動作確認に最適。",
                        analogy: "🔧 例え話：新しく買った電化製品で「テストボタン」を押すようなもの。「Hello World」が表示されれば、全部正常に動いています！"
                    },
                    {
                        text: "docker stop container_name",
                        explanation: "実行中のコンテナを停止します。container_nameの部分には実際のコンテナ名やIDを指定します。",
                        practical: "⏹️ 具体的にできること：メンテナンス前にWebサーバーを安全に停止したり、リソースを大量消費しているコンテナを一時停止してPCを軽くできます。",
                        analogy: "🛑 例え話：走行中の車を安全に停車させるようなもの。急ブレーキではなく、プログラムが正常に終了処理を行ってから停止します。"
                    },
                    {
                        text: "docker rm container_name",
                        explanation: "停止中のコンテナを削除します。不要なコンテナを片付ける際に使用します。",
                        practical: "🗑️ 具体的にできること：テスト用コンテナや失敗したビルド結果を削除してディスク容量を回復。大量のコンテナでPCが重くなるのを防げます。",
                        analogy: "🗂️ 例え話：使い終わったコピー用紙をゴミ箱に捨てるようなもの。ファイル自体はもう不要だけど、元の書類（イメージ）はまだ保管庫に残っています。"
                    },
                    {
                        text: "docker rmi image_name",
                        explanation: "指定したDockerイメージを削除します。ディスク容量を節約したい時に使用します。",
                        practical: "💽 具体的にできること：古いバージョンのアプリや使わなくなったツールのイメージを削除して、数GB〜数十GBのディスク容量を回復できます。",
                        analogy: "💿 例え話：もう見ないDVDをメルカリで売るようなもの。本棚から完全に取り除いて、スペースを空けます。また必要になったら買い直し（pull）できます。"
                    },
                    {
                        text: "docker exec -it container_name bash",
                        explanation: "実行中のコンテナ内でbashシェルを起動し、対話的にコマンドを実行できるようにします。",
                        practical: "💻 具体的にできること：動いているWebサーバーの内部に入って設定変更、ログ確認、デバッグ、ファイル編集などができます。リモートでの作業に必須！",
                        analogy: "🏠 例え話：稼働中のオフィスビルに「管理人として入る」ようなもの。外からではできない内部のメンテナンスや点検を、建物を止めずに実行できます。"
                    }
                ]
            },
            {
                level: "Dockerfile基礎",
                description: "Dockerfileの基本的な書き方を学習します。独自のイメージを作成するための重要な知識です。",
                commands: [
                    {
                        text: "FROM ubuntu:20.04",
                        explanation: "Dockerfileの最初に書く命令。ベースとなるイメージを指定します。ここではUbuntu 20.04を基盤にします。",
                        practical: "🏗️ 具体的にできること：WebアプリやAPI開発時に、安定したLinux環境を基盤として使えます。チーム全体で同じ基盤を使って環境の違いをなくせます。",
                        analogy: "🏠 例え話：家を建てる時の「土台・基礎工事」のようなもの。どんな土地（OS）の上に建てるかを最初に決めます。しっかりした基礎があってこそ、その上に部屋を作れます。"
                    },
                    {
                        text: "RUN apt update",
                        explanation: "イメージ作成時に実行するコマンドです。パッケージリストを最新に更新します。",
                        practical: "🔄 具体的にできること：セキュリティパッチや最新のソフトウェア情報を取得して、安全で最新の開発環境を構築できます。",
                        analogy: "📰 例え話：引っ越した新居で「近所にどんなお店があるか」の最新情報をインターネットで調べるようなもの。古い情報だと閉店したお店に行ってしまうかも。"
                    },
                    {
                        text: "RUN apt install -y curl",
                        explanation: "curlパッケージをインストールします。-yオプションで確認なしで実行します。",
                        practical: "🔧 具体的にできること：APIとの通信テストやファイルダウンロード機能を追加できます。Webアプリ開発では必須のツールです。",
                        analogy: "🛠️ 例え話：新居に「インターネット回線」を開通させるようなもの。これがあると外部との通信（API呼び出し）ができるようになります。"
                    },
                    {
                        text: "COPY ./hello.txt /app/",
                        explanation: "ホスト側のファイル（hello.txt）をコンテナ内の/app/ディレクトリにコピーします。",
                        practical: "📁 具体的にできること：アプリのソースコード、設定ファイル、静的ファイルをコンテナに組み込んで、完全に自己完結したアプリイメージを作成できます。",
                        analogy: "📦 例え話：引っ越しで「お気に入りの家具を新居に運ぶ」ようなもの。開発したコードという家具を、新しいコンテナという部屋に配置します。"
                    },
                    {
                        text: "WORKDIR /app",
                        explanation: "作業ディレクトリを/appに設定します。以降のコマンドはこのディレクトリで実行されます。",
                        practical: "📂 具体的にできること：アプリのファイルを整理して、コマンド実行時のパスミスを防げます。チーム開発で作業場所を統一できます。",
                        analogy: "🗃️ 例え話：オフィスで「今日の作業は会議室Aで行います」と決めるようなもの。以降の作業は全てその部屋が基準になるので、迷子になりません。"
                    },
                    {
                        text: "ENV NODE_ENV=production",
                        explanation: "環境変数を設定します。コンテナ実行時にも有効な変数です。",
                        practical: "⚙️ 具体的にできること：本番環境・開発環境・テスト環境でアプリの動作を自動的に切り替えられます。デバッグモードのON/OFFなども制御可能。",
                        analogy: "🏷️ 例え話：レストランで「今日のスペシャルメニュー」を壁に貼るようなもの。スタッフ全員がそれを見て、お客さんに適切な対応ができます。"
                    },
                    {
                        text: "ARG BUILD_VERSION=1.0",
                        explanation: "ビルド時のみ有効な変数を定義します。イメージ作成時にカスタマイズ可能です。",
                        practical: "🔧 具体的にできること：同じDockerfileから開発版・ステージング版・本番版を作り分けできます。バージョン番号やビルド設定を柔軟に変更可能。",
                        analogy: "📝 例え話：ケーキを作る時の「砂糖の量は後で決める」みたいなもの。レシピは同じだけど、甘さ控えめ版・普通版・激甘版を作り分けられます。"
                    },
                    {
                        text: "EXPOSE 3000",
                        explanation: "コンテナがリッスンするポートを宣言します。実際のポート公開にはdocker run時の-pオプションが必要です。",
                        practical: "🌐 具体的にできること：WebサーバーやAPIサーバーのポート番号を明示して、ネットワーク設定やセキュリティ設定を適切に行えます。",
                        analogy: "🚪 例え話：アパートの部屋番号を表札に書くようなもの。「この部屋（コンテナ）は3000番でお客さんを待ってます」という看板。ただし鍵（ポート開放）は別途必要。"
                    },
                    {
                        text: "CMD [\"node\", \"app.js\"]",
                        explanation: "コンテナ起動時のデフォルトコマンドを設定します。配列形式で記述します。",
                        practical: "▶️ 具体的にできること：コンテナを起動したら自動的にWebサーバーやアプリが立ち上がります。手動でコマンド入力する手間が不要になります。",
                        analogy: "⏰ 例え話：目覚まし時計をセットするようなもの。コンテナという部屋の住人が起きたら、自動的に「app.jsを実行して」という行動を開始します。"
                    },
                    {
                        text: "ENTRYPOINT [\"docker-entrypoint.sh\"]",
                        explanation: "コンテナの実行時に必ず実行されるコマンドを設定します。CMDと組み合わせて使用されることが多いです。",
                        practical: "🔐 具体的にできること：初期設定スクリプトや認証処理を必ず実行させたり、コンテナが予期しない方法で使われることを防げます。",
                        analogy: "🔑 例え話：会社のIDカードをかざして入室するシステムのようなもの。どんな目的で来てもセキュリティチェックは必ず通る。その後で各自の業務に向かいます。"
                    }
                ]
            },
            {
                level: "コンテナ操作",
                description: "コンテナの作成、実行、管理に関する実践的なコマンドを学習します。",
                commands: [
                    {
                        text: "docker run -it ubuntu:20.04 bash",
                        explanation: "Ubuntuコンテナを対話的(-it)モードで起動し、bashシェルを実行します。",
                        practical: "💻 具体的にできること：クリーンなLinux環境で開発ツールのテストや、本番環境のトラブルシューティング、学習用の実験環境として活用できます。",
                        analogy: "🖥️ 例え話：ネットカフェで新しいPCを借りるようなもの。まっさらな状態のUbuntu環境で、自由にコマンドを試すことができます。使い終わったら返却（削除）。"
                    },
                    {
                        text: "docker run -d nginx",
                        explanation: "nginxコンテナをバックグラウンド(-d)で実行します。Webサーバーとして動作します。",
                        practical: "🌐 具体的にできること：静的サイトのホスティング、リバースプロキシの構築、ロードバランサーとして使用。本番サーバーのテスト環境も簡単に構築可能。",
                        analogy: "🏪 例え話：24時間営業のコンビニを開店するようなもの。店長（nginx）は裏方で働き続けて、お客さん（ブラウザ）が来たらいつでも商品（Webページ）を提供します。"
                    },
                    {
                        text: "docker run -p 8080:80 nginx",
                        explanation: "nginxコンテナを起動し、ホストの8080ポートをコンテナの80ポートにマッピングします。",
                        practical: "🔗 具体的にできること：localhost:8080でWebサイトにアクセス可能になります。複数のサービスを異なるポートで同時実行でき、開発効率が向上。",
                        analogy: "📞 例え話：会社の代表番号(8080)にかかってきた電話を、担当部署の内線(80)に転送するようなもの。外部からは8080で、内部では80で処理されます。"
                    },
                    {
                        text: "docker run -v /host/path:/container/path ubuntu",
                        explanation: "ホストのディレクトリをコンテナ内にマウントします。データの永続化に使用します。",
                        practical: "💾 具体的にできること：開発中のコードやデータベースファイルを永続化でき、コンテナを削除してもデータが保持されます。バックアップ戦略にも重要。",
                        analogy: "🗄️ 例え話：レンタルオフィスに自分の書類キャビネットを持ち込むようなもの。オフィス（コンテナ）が変わっても、大切な書類（データ）は手元に残ります。"
                    },
                    {
                        text: "docker run --name my-container ubuntu",
                        explanation: "コンテナに「my-container」という名前を付けて起動します。管理が楽になります。",
                        practical: "🏷️ 具体的にできること：複数のコンテナを管理する時に、わかりやすい名前で識別できます。運用スクリプトでコンテナを指定しやすくなります。",
                        analogy: "👥 例え話：ペットに名前を付けるようなもの。「あの茶色い猫」ではなく「タマ」と呼ぶ方が、家族みんなにとって分かりやすいですよね。"
                    },
                    {
                        text: "docker logs container_name",
                        explanation: "指定したコンテナのログを表示します。デバッグやトラブルシューティングに使用します。",
                        practical: "🔍 具体的にできること：アプリのエラー原因調査、パフォーマンス分析、セキュリティ監査に使用。本番環境での障害対応には必須のコマンドです。",
                        analogy: "📖 例え話：お店の営業日報を読むようなもの。「今日は何人来店した」「どんなトラブルがあった」「何時に何が起きた」がすべて記録されています。"
                    },
                    {
                        text: "docker inspect container_name",
                        explanation: "コンテナの詳細情報をJSON形式で表示します。設定や状態を確認できます。",
                        practical: "🔧 具体的にできること：ネットワーク設定、環境変数、マウント情報などを詳細に確認でき、設定ミスやネットワークトラブルの原因を特定できます。",
                        analogy: "🔬 例え話：車の詳細なスペックシートを見るようなもの。エンジン、タイヤ、燃費、オプション装備など、すべての情報が技術者向けに詳細に記載されています。"
                    },
                    {
                        text: "docker restart container_name",
                        explanation: "指定したコンテナを再起動します。停止→開始を一度に実行します。",
                        practical: "🔄 具体的にできること：設定変更後の反映、メモリリーク解消、定期メンテナンス時の再起動。Webサーバーやデータベースの運用で日常的に使用。",
                        analogy: "🔌 例え話：調子の悪いスマホを「電源ボタン長押しで再起動」するようなもの。一旦完全に停止してから、もう一度起動して状態をリフレッシュします。"
                    },
                    {
                        text: "docker pause container_name",
                        explanation: "実行中のコンテナを一時停止します。メモリ状態は保持されます。",
                        practical: "⏸️ 具体的にできること：リソース節約や、他の重要なタスクのためにCPUを一時的に空けたい時に使用。処理を中断せずに一時停止できます。",
                        analogy: "⏸️ 例え話：動画再生の一時停止ボタンのようなもの。再生位置やプレイリストはそのまま保持して、CPUの処理だけを止めます。再開すればすぐ続きから始まります。"
                    },
                    {
                        text: "docker unpause container_name",
                        explanation: "一時停止したコンテナを再開します。pauseとセットで使用します。",
                        practical: "▶️ 具体的にできること：一時停止していたコンテナを、停止した瞬間の状態から即座に再開できます。長時間の処理を途中で中断・再開する場合に便利。",
                        analogy: "▶️ 例え話：一時停止していた動画の再生ボタンを押すようなもの。止めた瞬間から、何事もなかったかのように処理が続行されます。"
                    }
                ]
            },
            {
                level: "イメージ管理",
                description: "Dockerイメージのビルド、管理、配布に関するコマンドを習得します。",
                commands: [
                    {
                        text: "docker build -t my-app:v1 .",
                        explanation: "現在のディレクトリのDockerfileを使ってイメージをビルドし、my-app:v1というタグを付けます。",
                        practical: "📦 具体的にできること：WebアプリやAPIサーバーの本番環境用イメージを作成できます。チーム全員が同じ環境で開発・テストできるようになります。",
                        analogy: "🏗️ 例え話：設計図（Dockerfile）を元に、工場で製品（イメージ）を作って、製品番号（タグ）を付けるようなものです。"
                    },
                    {
                        text: "docker build --no-cache -t my-app .",
                        explanation: "キャッシュを使用せずにイメージをビルドします。確実に最新の状態でビルドしたい時に使用します。",
                        practical: "🔄 具体的にできること：セキュリティパッチが適用された最新のベースイメージを使って、完全にクリーンなイメージを作成できます。",
                        analogy: "🧹 例え話：料理で「昨日の残り物は使わずに、全部新鮮な食材から作り直す」ようなものです。時間はかかるけど確実に新鮮！"
                    },
                    {
                        text: "docker tag my-app:v1 my-app:latest",
                        explanation: "既存のイメージに新しいタグを付けます。バージョン管理やリリース管理に使用します。",
                        practical: "🏷️ 具体的にできること：テスト済みのv1.0を「最新版」として公開したり、開発版・ステージング版・本番版を区別して管理できます。",
                        analogy: "📚 例え話：同じ本に「初版」「最新版」「ベストセラー」などの複数のシールを貼るようなもの。中身は同じでも用途で呼び方を変えられます。"
                    },
                    {
                        text: "docker push my-app:v1",
                        explanation: "イメージをDocker Hubなどのレジストリにアップロードします。",
                        practical: "☁️ 具体的にできること：作成したアプリを世界中に公開したり、チームメンバーが同じイメージをダウンロードして使えるようになります。",
                        analogy: "📤 例え話：YouTubeに動画をアップロードするように、作った作品をオンラインの図書館（レジストリ）に置いて、誰でもダウンロードできるようにすること。"
                    },
                    {
                        text: "docker save -o my-app.tar my-app:v1",
                        explanation: "イメージをTARファイルとして保存します。オフライン環境での移動に使用します。",
                        practical: "💾 具体的にできること：インターネットに接続できないサーバーにアプリを持ち込んだり、USBでイメージをバックアップ・移動できます。",
                        analogy: "📦 例え話：大きな荷物を段ボール箱に梱包して、宅急便で送れるようにするイメージ。ネットが使えない場所でも物理的に運べます。"
                    },
                    {
                        text: "docker load -i my-app.tar",
                        explanation: "TARファイルからイメージを読み込みます。saveとセットで使用します。",
                        practical: "📥 具体的にできること：他の人から受け取ったイメージファイルを自分のPCに取り込んだり、バックアップからイメージを復元できます。",
                        analogy: "📦 例え話：宅急便で届いた段ボール箱を開けて、中身を棚に並べるようなもの。梱包された状態から使える状態に戻します。"
                    },
                    {
                        text: "docker history my-app:v1",
                        explanation: "イメージの作成履歴を表示します。各レイヤーのサイズや作成コマンドを確認できます。",
                        practical: "🔍 具体的にできること：イメージが巨大になった原因を調べたり、どの処理でサイズが増えたかを特定してイメージを最適化できます。",
                        analogy: "📋 例え話：ケーキのレシピと作成手順を振り返るようなもの。「この工程で生地が重くなった」「ここでクリームを追加した」など、各段階を確認できます。"
                    },
                    {
                        text: "docker image prune",
                        explanation: "使用されていないイメージを削除します。ディスク容量の節約に使用します。",
                        practical: "🗑️ 具体的にできること：開発中に溜まった古いビルドファイルや、もう使わないテスト用イメージを削除してPC容量を回復できます。",
                        analogy: "🧹 例え話：クローゼットの大掃除で「もう着ない服」を処分するようなもの。必要なものは残して、不要なものだけ片付けてスペースを確保。"
                    },
                    {
                        text: "docker system prune",
                        explanation: "使用されていないコンテナ、ネットワーク、イメージを一括削除します。",
                        practical: "🧽 具体的にできること：開発環境をリセットして、ディスク容量を大幅に回復できます。何GB分ものスペースが戻ることも！",
                        analogy: "🏠 例え話：家全体の大掃除。使わなくなった家具、古い雑誌、壊れた電化製品をまとめて処分して、家をスッキリさせるようなもの。"
                    },
                    {
                        text: "docker commit container_name new-image:tag",
                        explanation: "コンテナの現在の状態から新しいイメージを作成します。",
                        practical: "📸 具体的にできること：手動で設定変更したコンテナの状態を保存して、同じ環境を他の場所で再現できるイメージを作成できます。",
                        analogy: "📷 例え話：お気に入りの部屋の配置を写真に撮って、引っ越し先でも同じレイアウトを再現できるようにするようなもの。その瞬間の状態を永続化！"
                    }
                ]
            },
            {
                level: "実践応用",
                description: "Docker Composeや実際のアプリケーション開発で使用する実践的なコマンドです。",
                commands: [
                    {
                        text: "docker-compose up -d",
                        explanation: "docker-compose.ymlファイルに定義されたサービスをバックグラウンドで起動します。",
                        practical: "🚀 具体的にできること：Webサーバー+データベース+Redis等の複数サービスを一括起動。マイクロサービス構成の本番環境を1コマンドで立ち上げ可能。",
                        analogy: "🏘️ 例え話：住宅団地の一斉入居のようなもの。電気・ガス・水道・インターネットを各家庭に一斉に開通させて、街全体を同時に機能させます。"
                    },
                    {
                        text: "docker-compose down",
                        explanation: "Docker Composeで起動したサービスを停止し、関連するリソースを削除します。",
                        practical: "🛑 具体的にできること：開発終了時にすべてのサービスを安全に停止・削除。ネットワークやボリュームもクリーンアップして、環境をリセットできます。",
                        analogy: "🏘️ 例え話：引っ越しで住宅団地を一斉に退去するようなもの。電気・ガス・水道を各家庭から同時に停止して、街を空にします。きれいに元に戻します。"
                    },
                    {
                        text: "docker run --rm alpine echo 'Hello Docker'",
                        explanation: "一時的なコンテナを実行し、終了後に自動削除します。テストや一回限りの実行に便利です。",
                        practical: "🧪 具体的にできること：ワンライナーのテスト実行、スクリプト検証、バッチ処理実行が可能。コンテナが残らないのでディスク容量を圧迫しません。",
                        analogy: "🎪 例え話：お祭りの露店のようなもの。必要な時だけ設営して、お祭りが終わったら跡形もなく片付けます。次のお祭りではまた新しく設営。"
                    },
                    {
                        text: "docker run -e NODE_ENV=development node:16",
                        explanation: "環境変数を設定してコンテナを起動します。アプリケーションの動作モードを制御できます。",
                        practical: "⚙️ 具体的にできること：開発・ステージング・本番環境でアプリの動作を切り替え。デバッグモード、ログレベル、API接続先などを環境に応じて調整可能。",
                        analogy: "🎭 例え話：舞台俳優が役柄に応じて衣装を着替えるようなもの。同じ俳優（アプリ）でも、コメディ・悲劇・ミュージカルで演技（動作）を変えます。"
                    },
                    {
                        text: "docker network create my-network",
                        explanation: "カスタムネットワークを作成します。コンテナ間の通信を制御できます。",
                        practical: "🌐 具体的にできること：マイクロサービス間のセキュアな通信、サービス分離、ロードバランサー構成が可能。セキュリティグループのような役割も。",
                        analogy: "🏢 例え話：会社内に専用のビジネス電話網を構築するようなもの。部署間の連絡は内線で、外部とは遮断された安全な通信ネットワークを作ります。"
                    },
                    {
                        text: "docker run --network my-network nginx",
                        explanation: "指定したネットワークでコンテナを起動します。",
                        practical: "🔗 具体的にできること：特定のサービスグループにコンテナを参加させ、他のグループからアクセスできないセキュアな環境を構築できます。",
                        analogy: "🏢 例え話：新入社員を特定の部署の内線ネットワークに登録するようなもの。その部署の人とは内線で話せるけど、他部署への直通回線は制限されます。"
                    },
                    {
                        text: "docker volume create my-volume",
                        explanation: "名前付きボリュームを作成します。データの永続化に使用します。",
                        practical: "💾 具体的にできること：データベースファイル、ログファイル、設定ファイルの永続化。コンテナが削除されてもデータが保持され、バックアップも可能。",
                        analogy: "🗄️ 例え話：銀行の貸金庫を借りるようなもの。会社（コンテナ）が倒産しても、大切な資産（データ）は安全な場所に保管されて残ります。"
                    },
                    {
                        text: "docker run -v my-volume:/data ubuntu",
                        explanation: "作成したボリュームをコンテナにマウントします。",
                        practical: "📁 具体的にできること：複数のコンテナで同じデータを共有したり、データのバックアップ・復元が簡単に。データベースやファイルサーバーの運用に必須。",
                        analogy: "🗄️ 例え話：貸金庫の鍵を新しいオフィス（コンテナ）に持って行くようなもの。オフィスが変わっても、同じ金庫の中身にアクセスできます。"
                    },
                    {
                        text: "docker exec -u root container_name bash",
                        explanation: "指定したユーザー（ここではroot）でコンテナ内でコマンドを実行します。",
                        practical: "👑 具体的にできること：管理者権限が必要なシステム設定変更、パッケージインストール、セキュリティ設定変更。緊急時のシステム復旧作業に。",
                        analogy: "🔑 例え話：オフィスビルにマスターキーで入るようなもの。普通の社員では入れない管理室や設備室にもアクセスして、建物全体の設定を変更できます。"
                    },
                    {
                        text: "docker stats container_name",
                        explanation: "コンテナのリソース使用状況（CPU、メモリなど）をリアルタイムで表示します。",
                        practical: "📊 具体的にできること：パフォーマンス監視、リソース最適化、障害の早期発見が可能。本番環境のキャパシティプランニングやコスト削減に重要。",
                        analogy: "🏥 例え話：病院の患者モニターのようなもの。心拍数（CPU）、血圧（メモリ）、体温（ディスク使用量）をリアルタイムで監視して、異常があれば即座に対応。"
                    }
                ]
            }
        ];

        let currentLevel = 0;
        let currentCommandIndex = 0;
        let startTime = null;
        let isTyping = false;
        let totalCharactersTyped = 0;
        let correctCharacters = 0;
        let completedCommands = 0;
        
        // 音声合成関連の変数
        let speechSynthesis = window.speechSynthesis;
        let currentUtterance = null;
        let isAutoSpeechEnabled = false;
        let speechSpeed = 1;

        const targetTextEl = document.getElementById('target-text');
        const typingInputEl = document.getElementById('typing-input');
        const wpmEl = document.getElementById('wpm');
        const accuracyEl = document.getElementById('accuracy');
        const currentLevelEl = document.getElementById('current-level');
        const progressEl = document.getElementById('progress');
        const progressFillEl = document.getElementById('progress-fill');
        const startBtnEl = document.getElementById('start-btn');
        const resetBtnEl = document.getElementById('reset-btn');
        const nextBtnEl = document.getElementById('next-btn');
        const resultsEl = document.getElementById('results');
        const finalStatsEl = document.getElementById('final-stats');
        const levelCompleteMsgEl = document.getElementById('level-complete-message');
        const levelTitleEl = document.getElementById('level-title');
        const levelDescriptionEl = document.getElementById('level-description');
        const commandExplanationEl = document.getElementById('command-explanation');
        const mistakeIndicatorEl = document.getElementById('mistake-indicator');
        
        // 音声合成関連の要素
        const readExplanationBtnEl = document.getElementById('read-explanation-btn');
        const stopSpeechBtnEl = document.getElementById('stop-speech-btn');
        const speechSpeedEl = document.getElementById('speech-speed');
        const autoSpeechToggleEl = document.getElementById('auto-speech-toggle');
        const speakingIndicatorEl = document.getElementById('speaking-indicator');

        function initializeLevel() {
            const level = dockerCommands[currentLevel];
            levelTitleEl.textContent = `レベル${currentLevel + 1}: ${level.level}`;
            levelDescriptionEl.textContent = level.description;
            currentCommandIndex = 0;
            completedCommands = 0;
            updateProgress();
            loadCommand();
        }

        function loadCommand() {
            const command = dockerCommands[currentLevel].commands[currentCommandIndex];
            targetTextEl.textContent = command.text;
            
            // まず音声を停止
            stopSpeech();
            
            // 基本説明を設定
            let explanationHTML = `<div class="explanation-section">${command.explanation}</div>`;
            
            // 具体的な活用例があれば追加
            if (command.practical) {
                explanationHTML += `<div class="practical-use">${command.practical}</div>`;
            }
            
            // 例え話があれば追加
            if (command.analogy) {
                explanationHTML += `<div class="analogy-section">${command.analogy}</div>`;
            }
            
            commandExplanationEl.innerHTML = explanationHTML;
            
            // テキストを文字ごとに分割してスパンで囲む
            const chars = command.text.split('').map((char, index) => 
                `<span class="char" data-index="${index}">${char === ' ' ? '&nbsp;' : char}</span>`
            ).join('');
            targetTextEl.innerHTML = chars;
            
            typingInputEl.value = '';
            typingInputEl.focus();
            updateCurrentChar(0);
            
            // 自動読み上げが有効な場合、少し遅延してから読み上げ開始
            if (isAutoSpeechEnabled) {
                setTimeout(() => {
                    readExplanation();
                }, 500);
            }
        }

        // 音声合成機能
        function readExplanation() {
            if (!speechSynthesis) {
                alert('お使いのブラウザは音声合成に対応していません。');
                return;
            }

            // 既存の読み上げを停止
            speechSynthesis.cancel();
            
            // 説明テキストを取得（HTMLタグを除去）
            const explanationText = commandExplanationEl.textContent || commandExplanationEl.innerText;
            
            if (!explanationText.trim()) {
                return;
            }

            // 音声合成の設定
            currentUtterance = new SpeechSynthesisUtterance(explanationText);
            currentUtterance.lang = 'ja-JP';
            currentUtterance.rate = speechSpeed;
            currentUtterance.pitch = 1;
            currentUtterance.volume = 0.8;

            // イベントリスナーを設定
            currentUtterance.onstart = () => {
                readExplanationBtnEl.disabled = true;
                stopSpeechBtnEl.disabled = false;
                speakingIndicatorEl.classList.add('show');
            };

            currentUtterance.onend = () => {
                readExplanationBtnEl.disabled = false;
                stopSpeechBtnEl.disabled = true;
                speakingIndicatorEl.classList.remove('show');
                currentUtterance = null;
            };

            currentUtterance.onerror = () => {
                readExplanationBtnEl.disabled = false;
                stopSpeechBtnEl.disabled = true;
                speakingIndicatorEl.classList.remove('show');
                currentUtterance = null;
            };

            // 読み上げ開始
            speechSynthesis.speak(currentUtterance);
        }

        function stopSpeech() {
            if (speechSynthesis && currentUtterance) {
                speechSynthesis.cancel();
                readExplanationBtnEl.disabled = false;
                stopSpeechBtnEl.disabled = true;
                speakingIndicatorEl.classList.remove('show');
                currentUtterance = null;
            }
        }

        function updateSpeechSpeed() {
            speechSpeed = parseFloat(speechSpeedEl.value);
            if (currentUtterance) {
                // 現在読み上げ中の場合、一旦停止して新しい速度で再開
                const currentText = currentUtterance.text;
                speechSynthesis.cancel();
                setTimeout(() => {
                    readExplanation();
                }, 100);
            }
        }

        function toggleAutoSpeech() {
            isAutoSpeechEnabled = !isAutoSpeechEnabled;
            autoSpeechToggleEl.classList.toggle('active', isAutoSpeechEnabled);
        }

        function updateCurrentChar(index) {
            const chars = targetTextEl.querySelectorAll('.char');
            chars.forEach((char, i) => {
                char.classList.remove('current');
                if (i === index) {
                    char.classList.add('current');
                }
            });
        }

        function updateProgress() {
            const totalCommands = dockerCommands[currentLevel].commands.length;
            progressEl.textContent = `${completedCommands}/${totalCommands}`;
            currentLevelEl.textContent = currentLevel + 1;
            
            const progressPercentage = (completedCommands / totalCommands) * 100;
            progressFillEl.style.width = `${progressPercentage}%`;
        }

        function calculateWPM() {
            if (!startTime) return 0;
            const timeElapsed = (Date.now() - startTime) / 60000; // 分に変換
            const wordsTyped = correctCharacters / 5; // 平均的な単語の長さを5文字として計算
            return Math.round(wordsTyped / timeElapsed) || 0;
        }

        function calculateAccuracy() {
            if (totalCharactersTyped === 0) return 100;
            return Math.round((correctCharacters / totalCharactersTyped) * 100);
        }

        function updateStats() {
            wpmEl.textContent = calculateWPM();
            accuracyEl.textContent = `${calculateAccuracy()}%`;
        }

        function showMistake() {
            mistakeIndicatorEl.classList.add('show');
            setTimeout(() => {
                mistakeIndicatorEl.classList.remove('show');
            }, 1000);
        }

        function handleInput() {
            const inputValue = typingInputEl.value;
            const targetText = dockerCommands[currentLevel].commands[currentCommandIndex].text;
            const chars = targetTextEl.querySelectorAll('.char');
            
            if (!isTyping && inputValue.length > 0) {
                isTyping = true;
                startTime = Date.now();
                targetTextEl.classList.add('active');
            }

            // 文字ごとの判定
            for (let i = 0; i < inputValue.length && i < targetText.length; i++) {
                const char = chars[i];
                if (inputValue[i] === targetText[i]) {
                    char.classList.remove('incorrect');
                    char.classList.add('correct');
                } else {
                    char.classList.remove('correct');
                    char.classList.add('incorrect');
                    if (totalCharactersTyped < inputValue.length) {
                        showMistake();
                    }
                }
            }

            // 現在の文字位置を更新
            updateCurrentChar(inputValue.length);

            // 統計を更新
            if (inputValue.length > totalCharactersTyped) {
                const newChars = inputValue.length - totalCharactersTyped;
                totalCharactersTyped += newChars;
                
                for (let i = totalCharactersTyped - newChars; i < totalCharactersTyped; i++) {
                    if (i < targetText.length && inputValue[i] === targetText[i]) {
                        correctCharacters++;
                    }
                }
            }

            updateStats();

            // 完了チェック
            if (inputValue === targetText) {
                completeCommand();
            }
        }

        function completeCommand() {
            completedCommands++;
            updateProgress();
            
            setTimeout(() => {
                if (currentCommandIndex < dockerCommands[currentLevel].commands.length - 1) {
                    currentCommandIndex++;
                    loadCommand();
                } else {
                    completeLevel();
                }
            }, 1000);
        }

        function completeLevel() {
            isTyping = false;
            targetTextEl.classList.remove('active');
            
            const finalWPM = calculateWPM();
            const finalAccuracy = calculateAccuracy();
            
            finalStatsEl.textContent = `WPM: ${finalWPM} | 精度: ${finalAccuracy}%`;
            
            if (currentLevel < dockerCommands.length - 1) {
                levelCompleteMsgEl.textContent = "レベル完了！次のレベルに進みますか？";
                nextBtnEl.style.display = 'inline-block';
            } else {
                levelCompleteMsgEl.textContent = "全レベル完了！おめでとうございます！";
                nextBtnEl.style.display = 'none';
            }
            
            resultsEl.classList.add('show');
        }

        function resetGame() {
            isTyping = false;
            startTime = null;
            totalCharactersTyped = 0;
            correctCharacters = 0;
            currentCommandIndex = 0;
            completedCommands = 0;
            
            // 音声を停止
            stopSpeech();
            
            resultsEl.classList.remove('show');
            nextBtnEl.style.display = 'none';
            targetTextEl.classList.remove('active');
            
            updateProgress();
            loadCommand();
            updateStats();
        }

        function nextLevel() {
            if (currentLevel < dockerCommands.length - 1) {
                currentLevel++;
                resetGame();
                initializeLevel();
                updateLevelButtons();
            }
        }

        function updateLevelButtons() {
            const levelBtns = document.querySelectorAll('.level-btn');
            levelBtns.forEach((btn, index) => {
                btn.classList.remove('active');
                if (index === currentLevel) {
                    btn.classList.add('active');
                }
            });
        }

        // イベントリスナー
        typingInputEl.addEventListener('input', handleInput);

        startBtnEl.addEventListener('click', () => {
            resetGame();
            typingInputEl.focus();
        });

        resetBtnEl.addEventListener('click', resetGame);
        nextBtnEl.addEventListener('click', () => {
            resultsEl.classList.remove('show');
            nextLevel();
        });

        // レベル選択ボタン
        document.querySelectorAll('.level-btn').forEach((btn, index) => {
            btn.addEventListener('click', () => {
                currentLevel = index;
                resetGame();
                initializeLevel();
                updateLevelButtons();
            });
        });

        // 音声合成のイベントリスナー
        readExplanationBtnEl.addEventListener('click', readExplanation);
        stopSpeechBtnEl.addEventListener('click', stopSpeech);
        speechSpeedEl.addEventListener('input', updateSpeechSpeed);
        autoSpeechToggleEl.addEventListener('click', toggleAutoSpeech);

        // キーボードショートカット
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                stopSpeech(); // 音声も停止
                resetGame();
            } else if (e.key === 'Enter' && resultsEl.classList.contains('show')) {
                if (nextBtnEl.style.display !== 'none') {
                    nextLevel();
                } else {
                    resetGame();
                }
            } else if (e.key === 'F1') { // F1キーで読み上げ開始/停止
                e.preventDefault();
                if (currentUtterance) {
                    stopSpeech();
                } else {
                    readExplanation();
                }
            }
        });

        // 初期化
        function initializeSpeech() {
            // 音声合成の対応チェック
            if (!window.speechSynthesis) {
                readExplanationBtnEl.style.display = 'none';
                stopSpeechBtnEl.style.display = 'none';
                speechSpeedEl.parentElement.style.display = 'none';
                autoSpeechToggleEl.parentElement.style.display = 'none';
                console.warn('このブラウザは音声合成に対応していません。');
                return;
            }
            
            // 日本語音声の利用可能性チェック
            setTimeout(() => {
                const voices = speechSynthesis.getVoices();
                const japaneseVoices = voices.filter(voice => voice.lang.includes('ja'));
                if (japaneseVoices.length === 0) {
                    console.warn('日本語音声が見つかりません。英語で読み上げられる可能性があります。');
                }
            }, 100);
        }

        // 初期化
        initializeSpeech();
        initializeLevel();
        updateStats();
    </script>
</body>
</html>